#pragma config(Sensor, S1,     ntouch,         sensorTouch)
#pragma config(Sensor, S2,     nlight,         sensorLightActive)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

void forward()// this is the subroutine for making the robot go forward at half speed for 1 second
{
motor[motorB] = 50;// set motor B at half power
motor[motorC] = 50;// set motor C at half power
wait1Msec(1000);// for 1 second
}
void left()// this is the subroutine for making the robot go forward at half speed for 0.670 seconds
{
motor[motorB] = 0;// set motor B at half power
motor[motorC] = 50;// set motor C at half power
wait1Msec(0700);// for 0.7 seconds
}
void right()// this is the subroutine for making the robot go forward at half speed for 0.670 seconds
{
motor[motorB] = 50;// set motor B at half power
motor[motorC] = 0;// set motor C at half power
wait1Msec(0700);// for 0.670 seconds
}
void backwards()// this is the subroutine for making the robot go forward at half speed for 1 secon
{
motor[motorB] = -50;// set motor B at half power
motor[motorC] = -50;// set motor C at half power
wait1Msec(2000);//for 2 sconds
}
void wait()// this is the subroutine for making the robot sytop for 1 second
{
motor[motorB] = 0;// set motor B at zero power
motor[motorC] = 0;// set motor C at zero power
wait1Msec(1000);// for 1 second
}

task main()
{
while(SensorValue[ntouch] == 0)// do this untill the touch sensor is pressed
{
	forward();// call the forward subroutine
	motor[motorB] = 50;// the next 3 lines of code are to make the robot go a little further as it was too short
	motor[motorC] = 50;// and moving forward for 2 seconds was too long
	wait1Msec(0350);// mover forward for 0.350 seconds
	wait();// call the wait subroutine
	left();//call the left subroutine
	wait();//call the wait subroutine
	forward();// call the forward subroutine
	motor[motorB] = 50;// the next 3 lines of code are to make the robot go a little further as it was too short
	motor[motorC] = 50;// and moving forward for 2 seconds was too long
	wait1Msec(0450);// for 0.450 seconds

	wait();// call the wait subroutine
	right();//call the right subroutine
	wait();// call the wait subroutine
	forward();// call the forward subroutine
	motor[motorB] = 50;// the next 3 lines of code are to make the robot go a little further as it was too short
	motor[motorC] = 50;// and moving forward for 2 seconds was too long
	wait1Msec(1300);//for 1 second
	wait();
	if (SensorValue[nlight] < 100)// the robot will detect the black line and move backwards
	{
	backwards();//call the backwards subroutine
	}
	wait();// call the wait subroutine
	right();
	wait();// call the wait subroutine
	forward();// call the forward subroutine
	motor[motorB] = 50;
	motor[motorB] = 50;
	wait1Msec(300);
	wait();// call the wait subroutine
	left();// call the left subroutine
	wait();// call the wait subroutine
	motor[motorB] = 50;
	motor[motorB] = 50;
	wait1Msec(800);
	left();
	forward();
	if (SensorValue[nlight] < 100)// the light sesnor detects another black line
	{
	break;// btreak out the IF loop
	}
break;// btreak out the while loop
}
motor[motorB] = 0;//stop motor B
motor[motorC] = 0;// stop motor C
wait1Msec(7000);// for 7 seconds
}
